{
  "hash": "e93e071eebf39f72deca3ddbd565ce46",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Generalized Least Squares\"\nauthor: \"Chris Kelly\"\ndate: '06-11-24'\nimage: '../images/gls_fgls_wls.jpeg'\ncategories: [Linear Models, Generalized Least Squares]\nformat:\n  html:\n    code-fold: true\n    toc: true\n    code-links:\n      - text: OLS class\n        icon: file-code\n        href: ../src/ols_blue.py\n      - text: Sandwich class\n        icon: file-code\n        href: ../src/ols_sandwich_estimators.py\n      - text: GLS class\n        icon: file-code\n        href: ../src/gls_fgls_wls.py\n    other-links:\n      - text: Correcting SE for non-spherical errors\n        href: ols_sandwich_estimators.html\n    \n\n---\n\n::: {.callout-tip}\n### What are we exploring?\nApplying a weight matrix to correct for non-homoskedastic error variance can be more efficient than OLS with sandwich errors, aka GLS.\n:::\n\n## Introduction\n\nAs seen when exploring [sandwich estimators](ols_sandwich_estimators.html), the assumption of homoskedasticity is often violated in real-world data. This can lead to inefficient estimates and incorrect inference too. \n\nSandwich estimators correct for the variance by adjusting the standard error *after* OLS coefficient estimation. However, another approach is to correct for the variance *before* estimation - by first applying a weight matrix to the data before fitting. This is known as Generalized Least Squares (GLS). In fact, weighted least squares (WLS) is a special case of GLS.\n\n## The Motivation\n\nFirst - let’s state that:\n\n* $E(\\epsilon|X)=0$\n* $V(\\epsilon \\epsilon^{\\intercal}|X)=\\sigma^2\\underset{n \\times n}{\\Omega}$\n\nThis means that although the assumption of endogeneity is not violated, the assumption of homoskedasticity is. And more specifically, that the variance of the error term can be decomposed between into a constant variance $\\sigma^2$ and the error covariance matrix $\\Omega$.\n\nNow according to Cholesky decomposition, if $\\Omega$ is symmetric positive definite, then there exists a lower triangular matrix $\\mathrm{P}$ such that:\n\n$$\n\\displaylines{\n\\Omega=(\\mathrm{P}^{\\intercal}\\mathrm{P})^{-1} = \\mathrm{P}^{-1}(\\mathrm{P}^{\\intercal})^{-1} \\\\\n\\therefore \\mathrm{P} \\Omega \\mathrm{P}^{\\intercal} = I\n}\n$$\n\nSo, if we transform all variables by $\\mathrm{P}$:\n\n* We get the following form: $\\mathrm{P} y = \\mathrm{P} X\\beta + \\mathrm{P} \\epsilon$\n* Then the expected error is still zero (i.e. consistency): $E[\\mathrm{P} \\epsilon] = \\mathrm{P} E[\\epsilon] = 0$\n* But the variance is now homoskedastic: $V[\\mathrm{P} \\epsilon] = \\mathrm{P} V[\\epsilon] \\mathrm{P}^{\\intercal} = \\sigma^2 \\mathrm{P} \\Omega \\mathrm{P}^{\\intercal} = \\sigma^2 I$\n\n:::{.column-margin}\nIt might be apparent now that Weighted Least Squares (WLS) is a special case of GLS, where $\\mathrm{P}$ is an error covariance matrix has zero off-digonal elements. \n:::\n\nThis is the motivation behind GLS. We can transform the data by $\\mathrm{P}$ to make the error variance homoskedastic, and then apply OLS to the transformed data.\n\n## Checking the estimator is unbiased and more efficient\n\nFrom the above, we can use this to jump straight to the solution for the GLS estimator!\n$$\n\\displaylines{\n\\hat{\\beta}_{GLS} = \n[(\\mathrm{P} X)^{\\intercal}(\\mathrm{P} X)]^{-1}[(\\mathrm{P} X)^{\\intercal}(\\mathrm{P} y)] \\\\\n= \n[X^{\\intercal}\\mathrm{P}^{\\intercal}\\mathrm{P} X]^{-1}\n[X^{\\intercal}\\mathrm{P}^{\\intercal}\\mathrm{P} y] \\\\\n= [X^{\\intercal}\\Omega^{-1} X]^{-1}[X^{\\intercal}\\Omega^{-1} y]\n}\n$$\n\nWe can confirm this is unbiased:\n$$\n\\displaylines{\n\\begin{align}\n\\hat{\\beta}_{GLS} & = [X^{\\intercal}\\Omega^{-1} X]^{-1}[X^{\\intercal}\\Omega^{-1} y]\n\\\\ & = [X^{\\intercal}\\Omega^{-1} X]^{-1}\\left[X^{\\intercal}\\Omega^{-1}(X\\beta+\\epsilon)\\right]\n\\\\ & = \\left([X^{\\intercal}\\Omega^{-1} X]^{-1}\\left[X^{\\intercal}\\Omega^{-1}X\\right]\\right)\\beta + \\left([X^{\\intercal}\\Omega^{-1} X]^{-1}X^{\\intercal}\\Omega^{-1}\\right)\\epsilon\n\\\\ & = \\cancel{\\left([X^{\\intercal}\\Omega^{-1} X]^{-1}\\left[X^{\\intercal}\\Omega^{-1}X\\right]\\right)}\\beta + \\left([X^{\\intercal}\\Omega^{-1} X]^{-1}X^{\\intercal}\\Omega^{-1}\\right)\\epsilon\n\\\\ & = \\beta + [X^{\\intercal}\\Omega^{-1} X]^{-1}X^{\\intercal}\\Omega^{-1}\\epsilon\n\\\\ \\\\ \n\\therefore \n\\mathbb{E}[\\hat{\\beta}_{GLS}|X] & = \\mathbb{E} \\left[\n    \\left(\\beta + [X^{\\intercal}\\Omega^{-1} X]^{-1}X^{\\intercal}\\Omega^{-1}\\epsilon\\right)\n|X\\right]\n\\\\ & = \\beta + \\mathbb{E} \\left[ \n    \\left([X^{\\intercal}\\Omega^{-1} X]^{-1}X^{\\intercal}\\Omega^{-1}\\epsilon\\right)\n| X\\right]\n\\\\ & \\equiv \\beta + [X^{\\intercal}\\Omega^{-1} X]^{-1}X^{\\intercal}\\Omega^{-1} \\mathbb{E} \\left[ \n    \\epsilon\n| X\\right]\n\\\\ & = \\beta & \\iff \\mathbb{E}[\\epsilon|X] = 0\n\\end{align}\n}\n$$\n\nWe now show that the GLS estimator is more efficient than OLS. Firstly, we derive the variance of the GLS coefficient:\n\n$$\n\\displaylines{\n\\begin{align}\n\\mathbb{V}[\\hat{\\beta}_{GLS}] & = \n\\mathbb{E}[(\\hat{\\beta}_{GLS}-\\beta)(\\hat{\\beta}_{GLS}-\\beta)^{\\intercal}] \n\\\\ & = \\mathbb{E}[\n    ([X^{\\intercal}\\Omega^{-1} X]^{-1}X^{\\intercal}\\Omega^{-1}\\epsilon)\n    ([X^{\\intercal}\\Omega^{-1} X]^{-1}X^{\\intercal}\\Omega^{-1}\\epsilon)^{\\intercal}\n] \n\\\\ & \\equiv \\mathbb{E}[\n    ([X^{\\intercal}\\Omega^{-1} X]^{-1}X^{\\intercal}\\Omega^{-1})\\epsilon \\epsilon^{\\intercal}\n    (\\Omega^{-1} X [X^{\\intercal}\\Omega^{-1} X]^{-1})\n]\n\\\\ & =\n    ([X^{\\intercal}\\Omega^{-1} X]^{-1}X^{\\intercal}\\Omega^{-1})\n    \\underbrace{\\mathbb{E}[\\epsilon \\epsilon^{\\intercal}]}_{\\text{meat} = \\sigma^2\\Omega}\n    (\\Omega^{-1} X [X^{\\intercal}\\Omega^{-1} X]^{-1})\n\\\\ & =\n    \\sigma^2[X^{\\intercal}\\Omega^{-1} X]^{-1}X^{\\intercal}\\Omega^{-1}\n    \\cancel{\\Omega} \\cancel{\\Omega^{-1}} X [X^{\\intercal}\\Omega^{-1} X]^{-1}\n\\\\ & =\n    \\sigma^2\\cancel{[X^{\\intercal}\\Omega^{-1} X]^{-1}}\\cancel{X^{\\intercal}\\Omega^{-1} X}\n    [X^{\\intercal}\\Omega^{-1} X]^{-1}\n\\\\ & = \\sigma^2[X^{\\intercal}\\Omega^{-1} X]^{-1}\n\\end{align}\n}\n$$\n\nSo we can now compare that to the variance of the usual OLS estimator:\n\n$$\n\\displaylines{\n\\begin{align}\n\\mathbb{V}[\\hat{\\beta}_{OLS}] & = \n(X^{\\intercal}X)^{-1}X^{\\intercal}\n\\underbrace{E[\\epsilon\\epsilon^{\\intercal}]}_{\\text{meat} = \\sigma^2\\Omega}\nX(X^{\\intercal}X)^{-1}\n\\\\ & = \\sigma^2(X^{\\intercal}X)^{-1}X^{\\intercal} \\Omega X(X^{\\intercal}X)^{-1}\n\\\\ \\\\\n\\therefore\n\\mathbb{V}[\\hat{\\beta}_{OLS}] - \\mathbb{V}[\\hat{\\beta}_{GLS}] & = \n\\sigma^2 \\left[ \n    (X^{\\intercal}X)^{-1}X^{\\intercal} \\Omega X(X^{\\intercal}X)^{-1} - \n    [X^{\\intercal}\\Omega^{-1} X]^{-1} \n\\right] \\\\\n& = \\sigma^2 \\left[ A \\Omega A^{\\intercal} \\right] > 0\n\\\\ \\\\\n\\text{where } A & = (X^′X)^{−1}X^′− (X^′\\Omega^{−1}X)^{-1} X^′\\Omega^{−1}\n\\end{align}\n}\n$$\n\nAnd since $\\Omega$ is Positive Semi Definite, then $A \\Omega A^{\\intercal}$ is also PSD, so the GLS estimator is more efficient than the OLS estimator.\nFor the proof of the last step, see the footnotes[^1].\n\nHowever, this isn't feasible unless we know what $\\Omega$ is! We usually have to estimate this.\n\n## Feasible Generalized Least Squares\n\nThe feasible GLS estimator is a two-step process:\n\n1. Run a normal OLS regression, $y \\sim X\\hat{\\beta} + \\hat{\\epsilon}$. Now derive an error covariance matrix using the squared residuals from this OLS regression, $\\hat{\\Omega} \\sim \\mathrm{V}[\\hat{\\epsilon}]$, .\n2. Estimate $\\mathrm{P}$ using the Cholesky decomposition of $\\Omega$, and transform $y$ and $X$ by $\\mathrm{P}$. Then estimate another OLS model on the transformed data: $\\mathrm{P}y \\sim [\\mathrm{P}X]\\beta' + \\mathrm{P}\\epsilon$\n\nWhilst GLS is more efficient, FGLS is only *asymptotically* more efficient - when the error covariance matrix is consistently estimated. In fact, for a small sample size, FGLS can be actually less efficient than OLS - and often it is even biased! It is only for large samples that FGLS would be preferred, as it is consistent. \n\nThus some authors prefer OLS, and use a sandwich estimator instead. Finally - its worth noting that we can still apply sandwich estimator to FGLS coefficients as well!\n\n## Final notes\n\nIt is worth noting here that the random effects econometric model is a special case of GLS. The random effects model is a panel data model that assumes that the unobserved heterogeneity within groups is both constant and uncorrelated with the other predictors. is a special case of GLS. \n\n## Coding it up from scratch\n\nWe can inherit from the OLS class, as this does a lot of the leg work! We need to make two changes though:\n\n* Add an extra method to estimate the covariance matrix and apply the Cholesky decomposition. \n* Change the `_estimate_ls_coefs` method to utilise this covariance matrix.\n\nFirst we take the sandwich parent class we defined previously in the [sandwich estimator post](ols_sandwich_estimators.qmd.html) (note this also inherits from the OLS class - see that post [here](ols_blue.html)):\n\n<details>\n<summary>Sandwich class (source code):</summary>\n```{.python include='../src/ols_sandwich_estimators.py' }\n```\n</details>\n\n\n\nNow we can define a child GLS class, which utilises the parent classes in two key ways:\n\n* Uses the error covariance estimation methods from the sandwich class to estimate $\\Omega$\n* Uses the OLS class functionality to estimate the coefficients (and then other methods from OLS and sandwich for the standard errors etc)\n\n::: {#483687a1 .cell execution_count=2}\n``` {.python .cell-code}\nclass LS(ols_sandwich):\n\n    def __init__(\n        self, \n        y: Optional[np.ndarray] = None, \n        X: Optional[np.ndarray] = None,\n        omega: Optional[np.ndarray] = None\n        ) -> None:\n        \"\"\"Initializes the LS class to run an least-squares regression\"\"\"\n        super().__init__(y, X)\n        self.omega = omega\n        self.P = None\n\n    def _estimate_gls_coefs(self, y: np.ndarray, X: np.ndarray, omega: np.ndarray):\n        \"\"\"Estimates the GLS coefficients given a vector y and matrix X\"\"\"\n        try:\n            P = np.linalg.cholesky(omega)\n            PX = P.dot(X)\n            Py = P.dot(y)\n            coefs, XTOX_inv = self._estimate_ols_coefs(Py,PX)\n        except:\n            omega_inv = np.linalg.inv(omega)\n            XTO = X.T.dot(omega_inv)\n            XTOX = XTO.dot(X)\n            XTOX_inv = self._quick_matrix_invert(XTOX)\n            XTOY = XTO.dot(y)\n            coefs = XTOX_inv.dot(XTOY)\n        return coefs, XTOX_inv\n        \n    def fit(\n        self,\n        y: Optional[np.ndarray] = None,\n        X: Optional[np.ndarray] = None,\n        omega: Optional[np.ndarray] = None,\n        fgls = None,\n    ):\n        self._clear_fitted_attributes()\n        y = self._get_y(y)\n        X, exog_names = self._get_X(X)\n        if y is None or X is None:\n            raise ValueError('X and y is required for fitting')\n        if len(y) != X.shape[0]:\n            raise ValueError(\"y and X must be the same size.\")\n        self.y, self.X, self.exog_names = y, X, exog_names\n        self.n, self.k = X.shape\n        self.DoF = self.n - self.k\n        if omega is not None:\n            self.omega = omega\n        if self.omega is None:\n            self.beta, self.var_X_inv = self._estimate_ols_coefs(y,X)\n        if self.omega is not None or fgls is not None:\n            if self.omega is not None and fgls is not None:\n                raise ValueError('Cannot specify both omega and fgls')\n            elif fgls is not None:\n                self._assess_fit()\n                if type(fgls) == str:\n                      if fgls == \"homoskedastic\":\n                          self.omega = self._homoskedastic()\n                      elif fgls == \"heteroskedastic\":\n                          self.omega = self._heteroskedastic()\n                elif type(fgls) == np.ndarray:\n                    self.omega = self._clustered(fgls)\n            self._clear_fitted_attributes()\n            self.beta, self.var_X_inv = self._estimate_gls_coefs(y,X,self.omega)\n```\n:::\n\n\n<!-- Let's now compare it to statsmodels:\n\n::: {#4a7f76b9 .cell execution_count=3}\n``` {.python .cell-code}\nnp.random.seed(42)\nn, k = 200, 2\nsigma_sq = 1\nbeta = np.random.normal(size=(k,1))\nX = np.hstack([ \n  np.ones(n).reshape(n,1),\n  np.random.normal(size=(n,k-1)) \n  ])\ny = X.dot(beta) + np.random.normal(loc=0,scale=sigma_sq,size=(n,1))\ncl = np.repeat(np.arange(10), n/10)\nmodel = LS(y,X)\nmodel.fit()\nmodel.summary()\n```\n\n::: {.cell-output .cell-output-display execution_count=3}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Coefficient</th>\n      <th>Standard Error</th>\n      <th>Lower bound</th>\n      <th>Upper bound</th>\n      <th>test-statistic</th>\n      <th>p-value</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>0.570588</td>\n      <td>0.070282</td>\n      <td>0.431990</td>\n      <td>0.709186</td>\n      <td>8.118521</td>\n      <td>4.939418e-14</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>-0.044316</td>\n      <td>0.075569</td>\n      <td>-0.193339</td>\n      <td>0.104707</td>\n      <td>-0.586427</td>\n      <td>5.582568e-01</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#ac5ce30c .cell execution_count=4}\n``` {.python .cell-code}\nmodel.fit(omega=np.diagflat(np.arange(1,n+1)))\nmodel.summary()\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Coefficient</th>\n      <th>Standard Error</th>\n      <th>Lower bound</th>\n      <th>Upper bound</th>\n      <th>test-statistic</th>\n      <th>p-value</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>0.554508</td>\n      <td>0.007028</td>\n      <td>0.540648</td>\n      <td>0.568368</td>\n      <td>78.895699</td>\n      <td>1.468003e-151</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>-0.129972</td>\n      <td>0.007649</td>\n      <td>-0.145057</td>\n      <td>-0.114888</td>\n      <td>-16.991774</td>\n      <td>1.563731e-40</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#06e65495 .cell execution_count=5}\n``` {.python .cell-code}\nmodel.omega = None\nmodel.fit(fgls='homoskedastic')\nmodel.summary()\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Coefficient</th>\n      <th>Standard Error</th>\n      <th>Lower bound</th>\n      <th>Upper bound</th>\n      <th>test-statistic</th>\n      <th>p-value</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>0.570588</td>\n      <td>0.070770</td>\n      <td>0.431029</td>\n      <td>0.710147</td>\n      <td>8.062601</td>\n      <td>6.974507e-14</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>-0.044316</td>\n      <td>0.076093</td>\n      <td>-0.194372</td>\n      <td>0.105741</td>\n      <td>-0.582387</td>\n      <td>5.609684e-01</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#6116ed7f .cell execution_count=6}\n``` {.python .cell-code}\nmodel.omega = None\nmodel.fit(fgls='heteroskedastic')\nmodel.summary()\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Coefficient</th>\n      <th>Standard Error</th>\n      <th>Lower bound</th>\n      <th>Upper bound</th>\n      <th>test-statistic</th>\n      <th>p-value</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>0.787920</td>\n      <td>0.075926</td>\n      <td>0.638194</td>\n      <td>0.937647</td>\n      <td>10.377539</td>\n      <td>2.005613e-20</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>0.281053</td>\n      <td>0.083791</td>\n      <td>0.115816</td>\n      <td>0.446290</td>\n      <td>3.354224</td>\n      <td>9.537270e-04</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#44ee5ae6 .cell execution_count=7}\n``` {.python .cell-code}\nmodel.omega = None\nmodel.fit(fgls=cl)\nmodel.summary()\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>Coefficient</th>\n      <th>Standard Error</th>\n      <th>Lower bound</th>\n      <th>Upper bound</th>\n      <th>test-statistic</th>\n      <th>p-value</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>0.570588</td>\n      <td>9.614774e-11</td>\n      <td>0.570588</td>\n      <td>0.570588</td>\n      <td>5.934489e+09</td>\n      <td>0.0</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>-0.044316</td>\n      <td>1.312602e-10</td>\n      <td>-0.044316</td>\n      <td>-0.044316</td>\n      <td>-3.376160e+08</td>\n      <td>0.0</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#59740153 .cell execution_count=8}\n``` {.python .cell-code}\nmodel.omega\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```\narray([[ 1.00429811,  0.88623181, -1.51391572, ...,  0.        ,\n         0.        ,  0.        ],\n       [ 0.88623181,  0.7820455 , -1.33593826, ...,  0.        ,\n         0.        ,  0.        ],\n       [-1.51391572, -1.33593826,  2.28213197, ...,  0.        ,\n         0.        ,  0.        ],\n       ...,\n       [ 0.        ,  0.        ,  0.        , ...,  1.80491782,\n        -2.41623544, -1.03061939],\n       [ 0.        ,  0.        ,  0.        , ..., -2.41623544,\n         3.2346036 ,  1.37968558],\n       [ 0.        ,  0.        ,  0.        , ..., -1.03061939,\n         1.37968558,  0.58849013]])\n```\n:::\n:::\n\n\n::: {#f837ce3a .cell execution_count=9}\n``` {.python .cell-code}\nimport statsmodels.api as sm \nmodel = sm.GLS(y,X).fit()\n```\n:::\n\n\n-->\n\n[^1]: \n    To show that GLS is more efficient than the OLS estimator, we show that we can rewrite the difference in the variance of the two estimators as a positive semi-definite matrix $\\sigma^2 \\left[ A \\Omega A^{\\intercal} \\right]$:\n    $$\n    \\displaylines{\n    \\begin{align}\n    A & = \n    (X^{\\intercal}X)^{−1}X^{\\intercal}− (X^{\\intercal}\\Omega^{−1}X)^{-1} X^{\\intercal}\\Omega^{−1}\n    \\\\\n    \\therefore A^{\\intercal} & = X(X^{\\intercal}X)^{−1} − \\Omega^{−1} X (X^{\\intercal}\\Omega^{−1}X)^{-1}\n    & \\because \\left[\\Omega^{-1}\\right]^{\\intercal} = \\Omega^{-1}\n    \\\\ \\\\\n    \\Rightarrow A\\Omega & = \n    (X^{\\intercal}X)^{−1}X^{\\intercal}\\Omega − (X^{\\intercal}\\Omega^{−1}X)^{-1} X^{\\intercal}\n    \\\\ \\\\\n    \\Rightarrow A\\Omega A^{\\intercal} \n    & = (X^{\\intercal}X)^{−1}X^{\\intercal}\\Omega X(X^{\\intercal}X)^{−1} \\\\\n    & - (X^{\\intercal}\\Omega^{−1}X)^{-1} \\underbrace{X^{\\intercal} X(X^{\\intercal}X)^{−1}}_{=I} \\\\\n    & - \\underbrace{(X^{\\intercal}X)^{−1}X^{\\intercal}\\Omega \\Omega^{−1} X}_{=I} (X^{\\intercal}\\Omega^{−1}X)^{-1}  \\\\\n    & + (X^{\\intercal}\\Omega^{−1}X)^{-1}X^{\\intercal} \\underbrace{\\Omega^{−1} X (X^{\\intercal}\\Omega^{−1}X)^{-1}}_{=I} \\\\\n    \\\\ \n    \\Rightarrow \\sigma^2 \\left[ A \\Omega A^{\\intercal} \\right]\n    & = \n    \\underbrace{\\sigma^2(X^{\\intercal}X)^{−1}X^{\\intercal}\\Omega X(X^{\\intercal}X)^{−1}}_{V[\\beta^{OLS}]} - \\underbrace{\\sigma^2(X^{\\intercal}\\Omega^{−1}X)^{-1}}_{V[\\beta^{GLS}]} \\\\ \n    & \\cancel{-\\sigma^2(X^{\\intercal}\\Omega^{−1}X)^{-1}X^{\\intercal} + \\sigma^2(X^{\\intercal}\\Omega^{−1}X)^{-1}X^{\\intercal}}\n    \\end{align}\n    }\n    $$\n\n",
    "supporting": [
      "gls_fgls_wls_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}